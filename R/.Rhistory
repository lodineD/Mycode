#1.a
X = c(1,3,4,7,9)
Y = c(0.5,3.5,2.5,4,3)
ppp=data.frame(X,Y)
#1.b
Marks = c(0.5,1,1.5,4,5)
ppp$Marks=Marks
#1.c
Marks = c(1,2,1,2,1)
ppp$Marks=Marks
#1.d
install.packages("units")
library("units")
units(ppp$X)='m'
ppp$X
#1.d
install.packages("units")
library("units")
units(ppp$X)='m'
ppp$X
units(ppp$Y)='m'
ppp$Y
#1.e
units(ppp$X) = '42cm'
units(ppp$Y) = '42cm'
#1.f
xx = c(0,0,5,10,10)
yy = c(0,2,5,4,0)
plot(xx,yy)
polygon(xx,yy)
points(ppp$X,ppp$Y)
#1.g
xx = c(0,0,5,5)
yy = c(0,2,3,0)
plot(xx,yy)
polygon(xx,yy)
points(c(1,4),c(0.5,2.5))
#1.h
install.packages("splancs")
library("splancs")
library("sp")
poly1 = cbind(xx,yy)
csr_data = csr(poly1,10)
points(csr_data)
#2.a
q11 = read.csv("q11.csv",header=T)
install.packages("matlib")
inv(A)*B
library(matlib)
inv(A)*B
ls()
x = c(1, 2, -1)
y = c(0.4, 5, 8)
A = matrix(
c(4, -3, 1, 0.5, 2, 2, 6, 7, -2),
byrow = T,
nrow = 3,
ncol = 3
)
B = matrix(c(-1, 2, 1, -2, 3, 1),
byrow = T,
nrow = 3,
ncol = 2)
z = 2.3 * x - y / 7
z
print(z, digits = 2)
# 矩阵相乘
A %*% A
# 值相乘
A * A
library(matlib)
inv(A)*B
#q1
x = c(1,2,-1) # In R, c() function returns a vector
y = c(0.4,5,8)
A = matrix(c(
4,-3,1,
0.5,2,2,
6,7,-2
),byrow=T,nrow=3) # byrow is True, which means data is filled by rows
B = matrix(c(
-1,2,
1,-2,
3,1
),byrow=T,ncol=2)
#a
z = 2.3*x-y/7  #basic operator: + - * /
z
print(z,digits=2) # argument digits: minimal number of significant digits not decimal digits
#b
A %*% (2.3*x-y/7) # The operator %*% is used for matrix multiplication satisfying
# the condition that the number of columns in the first matrix is equal to the number
# of rows in second.
A %*% (z)
#c
x %*% y
t(x) %*% y
crossprod(x,y)
#d
outer(x,y,'*') # 'Fun'='*' is handled as a special case visa as.vector(x)%*%t(as.vector(y))
x %*% t(y)
#e
solve(A) %*% B
solve(A,B)
# install.packages("matlib")
library("matlib")
inv(A) %*% B
#f
solve(A,x) # solve(a,b) solves the equation a%*%x=b
#q2
price = c(179000,126500,134500)
area = c(3060,1600,2000)
acres = c(0.75,0.26,0.7)
rooms = c(8,8,8)
baths = c(2.0,1.5,1)
homes = data.frame(price,area,acres,rooms,baths)
homes = data.frame(price = c(179000,126500,134500),
area = c(3060,1600,2000),
acres = c(0.75,0.26,0.7),
rooms = c(8,8,8),
baths = c(2.0,1.5,1))
#
homes = read.table(text="
price area acres rooms baths
179000 3060 0.75 8 2.0
126500 1600 0.26 8 1.5
134500 2000 0.7 8 1
",header=T)
#setwd("D:\\lectures\\6016\\tutorials\\t0")
#getwd()
saveRDS(homes,file="homes.RData")
home = readRDS("homes.RData")
load("D:/cs/R/homes.RData")
ls()
clear()
load("D:/cs/R/homes.RData")
View(home)
install.packages('spatstat')
set.seed(123)
rnow(4)
nrow(4)
library(spatstat)
data(redwood)
myppp<-redwood
View(myppp)
ss<-summary(myppp)
(lambda <- ss$intensity)
library(spatstat)
# Set the seed for reproducibility
set.seed(123)
# Number of locations
n <- 50
# Generate random locations in a unit square
x <- runif(n)
y <- runif(n)
# Create a point pattern object
myppp <- ppp(x, y)
# Compute the nearest-neighbor distances
nn <- nn2(myppp)
# Calculate the intensity lambda (number of points per unit area)
lambda <- n / (max(x) - min(x)) / (max(y) - min(y))  # Area of the unit square
# Compute the statistic
statistic <- 2 * pi * lambda * sum(nn^2)
# Compute the nearest-neighbor distances
nn <- nn2(myppp)
library(spatstat)
# Set the seed for reproducibility
set.seed(123)
# Number of locations
n <- 50
# Generate random locations in a unit square
x <- runif(n)
y <- runif(n)
# Create a point pattern object
myppp <- ppp(x, y)
# Compute the nearest-neighbor distances
nn <- nn2(myppp)
install.packages('RANN')
library(RANN)
# Set the seed for reproducibility
set.seed(123)
# Number of locations
n <- 50
# Generate random locations in a unit square
x <- runif(n)
y <- runif(n)
# Create a point pattern object
myppp <- ppp(x, y)
# Compute the nearest-neighbor distances
nn <- nn2(myppp)
# Compute the nearest-neighbor distances
nn <- nndist(myppp)
# Calculate the intensity lambda (number of points per unit area)
lambda <- n / (max(x) - min(x)) / (max(y) - min(y))  # Area of the unit square
# Compute the statistic
statistic <- 2 * pi * lambda * sum(nn^2)
# Print the statistic
print(statistic)
library(spatstat)
library(RANN)
# Set the seed for reproducibility
set.seed(123)
# Number of locations
n <- 50
# Generate random locations in a unit square
x <- runif(n)
y <- runif(n)
# Create a point pattern object
myppp <- ppp(x, y)
# Compute the nearest-neighbor distances
nn <- nndist(myppp)
# Calculate the intensity lambda (number of points per unit area)
lambda <- n / (max(x) - min(x)) / (max(y) - min(y))  # Area of the unit square
# Compute the statistic
statistic <- 2 * pi * lambda * sum(nn^2)
# Print the statistic
print(statistic)
library(spatstat)
library(RANN)
# Set the seed for reproducibility
set.seed(123)
# Number of locations
n <- 50
# Generate random locations in a unit square
x <- runif(n)
y <- runif(n)
# Create a point pattern object
myppp <- ppp(x, y)
# Compute the nearest-neighbor distances
nn <- nndist(myppp)
# Calculate the intensity lambda (number of points per unit area)
lambda <- n / 1  # Area of the unit square
# Compute the statistic
statistic <- 2 * pi * lambda * sum(nn^2)
# Print the statistic
print(statistic)
View(myppp)
library(spatstat)
library(RANN)
set.seed(123)
# Number of simulations
num_sims <- 1000
# Store statistics from simulations
sim_stats <- numeric(num_sims)
# Perform simulations
for (i in 1:num_sims) {
x <- runif(n)
y <- runif(n)
myppp <- ppp(x, y)
nn <- nn2(myppp)
sim_stats[i] <- 2 * pi * lambda * sum(nn^2)
}
library(spatstat)
library(RANN)
set.seed(123)
# Number of simulations
num_sims <- 1000
# Store statistics from simulations
sim_stats <- numeric(num_sims)
# Perform simulations
for (i in 1:num_sims) {
x <- runif(n)
y <- runif(n)
myppp <- ppp(x, y)
nn <- nnlist(myppp)
sim_stats[i] <- 2 * pi * lambda * sum(nn^2)
}
library(spatstat)
library(RANN)
set.seed(123)
# Number of simulations
num_sims <- 1000
# Store statistics from simulations
sim_stats <- numeric(num_sims)
# Perform simulations
for (i in 1:num_sims) {
x <- runif(n)
y <- runif(n)
myppp <- ppp(x, y)
nn <- nndlist(myppp)
sim_stats[i] <- 2 * pi * lambda * sum(nn^2)
}
# Fit a distribution to the simulated statistics (e.g., normal)
fit <- fitdistr(sim_stats, "norm")
# Plot the histogram of simulated statistics
hist(sim_stats, probability = TRUE, col = "grey", border = "white")
curve(fit$estimate["mean"] + fit$estimate["sd"] * qnorm(x), col = "blue", add = TRUE)
library(MASS)
set.seed(123)
# Number of simulations
num_sims <- 1000
# Store statistics from simulations
sim_stats <- numeric(num_sims)
# Perform simulations
for (i in 1:num_sims) {
x <- runif(n)
y <- runif(n)
myppp <- ppp(x, y)
nn <- nndlist(myppp)
sim_stats[i] <- 2 * pi * lambda * sum(nn^2)
}
# Fit a distribution to the simulated statistics (e.g., normal)
fit <- fitdistr(sim_stats, "norm")
# Plot the histogram of simulated statistics
hist(sim_stats, probability = TRUE, col = "grey", border = "white")
curve(fit$estimate["mean"] + fit$estimate["sd"] * qnorm(x), col = "blue", add = TRUE)
