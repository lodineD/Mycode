pi.sim2 <- function(n) { # Define as a function
h1 <- cos(360/n/2)
b1 <- sin(360/2/n)
b2 <- tan(360/2/n)
pi.hat <- n*(h1*b1+b2)/2
pi.hat        # Output pi
}   # End of definition of function
pi.sim2(1000)
cos(360)
?cos
pi.sim2 <- function(n) { # Define as a function
h1 <- cos(pi/n)
b1 <- sin(pi/n)
b2 <- tan(pi/n)
pi.hat <- n*(h1*b1+b2)/2
pi.hat        # Output pi
}   # End of definition of function
pi.sim2(1000)
pi.sim2(1000)
pi.sim2(1000)
pi.sim2(100000)
pi.approx <- function(n) { # Define as a function
for (i in 1:n) {
h[i] <- (sqrt(1-i^2/n^2)+sqrt(1-(i-1)^2/n^2))/2
}
pi.app <- 4*sum(h/n)
pi.app
}
pi.app(10)
pi.approx(10)
pi.approx <- function(n) { # Define as a function
h <- numeric(n)
for (i in 1:n) {
h[i] <- (sqrt(1-i^2/n^2)+sqrt(1-(i-1)^2/n^2))/2
}
pi.app <- 4*sum(h/n)
pi.app
}
pi.approx(10)
pi.approx(100)
pi.approx(1000)
pi.approx(1000000)
pi.approx(1000000)
pi.approx(10000000)
pi.approx(100000000)
?bp
help(bptest)
??bptest
help.start()
?bptest
help(bptest)
??bptest
help.start()
help.start
ls()
c(1, "1")
c("1", 1)
c("1", TRUE)
c(1,TRUE)
# 2.3 Assign values to variables
# Assign scalar values
a <- 1; a               # Numeric
b = 2; b
a = b; a; b                # To see what happen
1 -> a; a
c <- "MStat"; c         # Character
d <- a>2; d             # Logical
# Assign vectors
x1 <- c(4, 2, 0); x1                # Numerical vector
c(1, 0, -1) -> x2; x2               # Numerical vector
assign("x3", c("A", "B", "C")); x3  # Character vector
x4 <- x1>=2; x4                     # Logical vector
f <- factor(c("A", "B","C", "A")); f      # Factor vector
c1 <- 1+2i; c1                      # Complex number
c2 <- c(1-i, 4+2i); c2              # Incorrect usage
type(c1)
mode(c1)
c2 <- complex(2, c(1,4), c(-1,2)); c2     # Complex vector
mode(c2)
######################################################################
# Chapter 2. R Commands and Objects
# 2.1 Use help
?bptest
help(bptest)
??bptest
help.start()
help.start
# 2.2 Create R objects
# Display and remove objects
objects()
rm(pi.sim)
ls()
# Define empty variable/vector/matrix
y1 <- numeric(); y1
y2 <- character(5); y2
y3 <- logical(2); y3
A <- matrix(nrow = 2, ncol = 3); A
# An example of character variable/vector
c(1:3, "String", NA, 0/0, 1/0, -1/0, TRUE, FALSE)
# An example of numeric variable/vector
c(1:3, NA, 0/0, 1/0, -1/0, TRUE, FALSE)
# 2.3 Assign values to variables
# Assign scalar values
a <- 1; a               # Numeric
b = 2; b
a = b; a; b                # To see what happen
1 -> a; a
c <- "MStat"; c         # Character
d <- a>2; d             # Logical
# Assign vectors
x1 <- c(4, 2, 0); x1                # Numerical vector
c(1, 0, -1) -> x2; x2               # Numerical vector
assign("x3", c("A", "B", "C")); x3  # Character vector
x4 <- x1>=2; x4                     # Logical vector
f <- factor(c("A", "B","C", "A")); f      # Factor vector
c1 <- 1+2i; c1                      # Complex number
mode(c1)
c2 <- c(1-i, 4+2i); c2              # Incorrect usage
View(a)                             # View a in editor
View(x1)                            # View x1 in editor
x2[2]                               # 2nd value of x2
x3[3]                               # 3rd value of x3
x1[c(1,3)]                          # 1st and 3rd values of x1
# Connect vectors to a new vector
x5 <- c(x1, 0, x2); x5            # 7-dimensional vector
# Generate regular sequences
x6 <- 1:6; x6
seq(from=0, to=20, by=5)
seq(from=2, by=-1, length=7)
rep(x1, times=3)
rep(x1, each=3)
# 2.4 Assign matrices
m1 <- matrix(c(x1, x2), nrow=3, ncol=2); m1   # Read by column
M1 <- cbind(x1, x2); M1                       # Combine by columns
m2 <- matrix(c(x1, x2), nrow = 2, ncol = 3,
byrow = T); m2                # Read by row
M2 <- rbind(x1, x2); M2                       # Combine by rows
# One more example of rbind() and cbind()
cbind(0, rbind(1, 1:3))
# Display row(s), column(s), or element(s) of a matrix
m1[1,]                        # 1st row of m1
m1[,2]                        # 2nd column of m1
m1[1,2]                       # (1,2)th element of m1
m1[2:3,1]                     # Values in rows 2 & 3, column 1
# 2.5 Define a data frame (data set)
data1 <- data.frame(x1, x2); View(data1)      # Define
data2 <- data.frame(X=x1, Y=x2); View(data2)  # Define and rename
# Add a variable (with the same length) to the data frame
data1$XX <- x3
View(data1)
data1$XX
mode(x1)
mode(x3)
mode(x4)
mode(c)
mode(f)
mode(m1)
mode(M1)
mode(data1)
length(M1)
M1
M1%*%M1
# 2.7 Define Arrays
# Define an empty array
A3 <- array(,dim = c(2,3,2)); A3
# See how values are put into the array
A3 <- array(1:12,dim = c(2,3,2)); A3
# Assign m2 as values of A3[,,1]
A3[,,1] <- m2; A3[,,1]
# Assign other numeric values
A3[,1,2] <- 0; A3
# Assign other character values
A3[,2,2] <- "B"; A3
############## R Workshop for Beginners ###############
#######################################################
# Chapter 1. Introduction
# Simulating the circumference pi
# as 4 times the inverse ratio of areas
# of a square and its inscribed circle
pi.sim <- function(n) { # Define as a function
x <- runif(n,-1,1)  # n random x-coordinates
y <- runif(n,-1,1)  # n random y-coordinates
covered <- as.numeric(x^2+y^2<1)
# Indicator of (x,y) falling in the unit circle
pi.hat <- mean(covered)*4
pi.hat        # Output pi
}   # End of definition of function
# Execution of the function
pi.sim(1000)
pi.sim(1000000)
######################################################################
# Chapter 2. R Commands and Objects
# 2.1 Use help
?bptest
help(bptest)
??bptest
help.start()
help.start
# 2.2 Create R objects
# Display and remove objects
objects()
rm(pi.sim)
ls()
# Define empty variable/vector/matrix
y1 <- numeric(); y1
y2 <- character(5); y2
y3 <- logical(2); y3
A <- matrix(nrow = 2, ncol = 3); A
# An example of character variable/vector
c(1:3, "String", NA, 0/0, 1/0, -1/0, TRUE, FALSE)
# An example of numeric variable/vector
c(1:3, NA, 0/0, 1/0, -1/0, TRUE, FALSE)
# 2.3 Assign values to variables
# Assign scalar values
a <- 1; a               # Numeric
b = 2; b
a = b; a; b             # To see what happen
2 -> a; a
c <- "MStat"; c         # Character
d <- a>2; d             # Logical
# Assign vectors
x1 <- c(4, 2, 0); x1                # Numerical vector
c(1, 0, -1) -> x2; x2               # Numerical vector
assign("x3", c("A", "B", "C")); x3  # Character vector
x4 <- x1>=2; x4                     # Logical vector
f <- factor(c("A", "B","C", "A")); f      # Factor vector
c1 <- 1+2i; c1                      # Complex number
mode(c1)
c2 <- c(1-i, 4+2i); c2              # Incorrect usage
c <- complex(2, c(1,4), c(-1,2)); c # Correct usage
View(a)                             # View a in editor
View(x1)                            # View x1 in editor
x2[2]                               # 2nd value of x2
x3[3]                               # 3rd value of x3
x1[c(1,3)]                          # 1st and 3rd values of x1
# Connect vectors to a new vector
x5 <- c(x1, 0, x2); x5            # 7-dimensional vector
# Generate regular sequences
x6 <- 1:6; x6
seq(from=0, to=20, by=5)
seq(from=2, by=-1, length=7)
rep(x1, times=3)
rep(x1, each=3)
# 2.4 Assign matrices
m1 <- matrix(c(x1, x2), nrow=3, ncol=2); m1   # Read by column
M1 <- cbind(x1, x2); M1                       # Combine by columns
m2 <- matrix(c(x1, x2), nrow = 2, ncol = 3,
byrow = T); m2                # Read by row
M2 <- rbind(x1, x2); M2                       # Combine by rows
# One more example of rbind() and cbind()
cbind(0, rbind(1, 1:3))
# Display row(s), column(s), or element(s) of a matrix
m1[1,]                        # 1st row of m1
m1[,2]                        # 2nd column of m1
m1[1,2]                       # (1,2)th element of m1
m1[2:3,1]                     # Values in rows 2 & 3, column 1
# 2.5 Define a data frame (data set)
data1 <- data.frame(x1, x2); View(data1)      # Define
data2 <- data.frame(X=x1, Y=x2); View(data2)  # Define and rename
# Add a variable (with the same length) to the data frame
data1$XX <- x3
View(data1)
data1$XX
# 2.6 Modes of objects
mode(x1)
mode(x3)
mode(x4)
mode(c)
mode(f)
mode(m1)
mode(M1)
mode(data1)
# lengths of vectors or data frames
length(x1)
length(data2)
# length of a matrix
length(m1)
# orders of a matrix
nrow(m1)
ncol(m1)
# orders of a data frame
nrow(data2)
ncol(data2)
# Change modes
x1; as.character(x1)
x4; as.numeric(x4)
# Change types
m2; as.data.frame(m2)
data2; as.matrix(data2)
# 2.7 Define Arrays
# Define an empty array
A3 <- array(,dim = c(2,3,2)); A3
# See how values are put into the array
A3 <- array(1:12,dim = c(2,3,2)); A3
# Assign m2 as values of A3[,,1]
A3[,,1] <- m2; A3[,,1]
# Assign other numeric values
A3[,1,2] <- 0; A3
# Assign other character values
A3[,2,2] <- "B"; A3
# Display/Use values
A3[2,c(1,3),1]
# Training exercises
# Q1.a)
TX1 <- seq(from=3, to=50, by=7); TX1
# Q1.b)
TX2 <- seq(from=45, to=0, by=-7); TX2
# Q1.c)
TX3 <- c(TX1, TX2); TX3
# Q1.d)
TX4 <- rep(TX1, 2); TX4
# Q1.e)
TX5 <- rep(TX2, each=2); TX5
# Q1.f)
TX6 <- rep(c("F","F","M"),5)[1:length(TX5)]; TX6
# Q1.g)
TX7 <- as.factor(TX6); TX7
# Q2.a)
TM1 <- matrix(c(TX1, TX2), length(TX1), 2); TM1
# Q2.b)
TM2 <- matrix(c(TX4, TX5), 2, length(TX4), byrow = T); TM2
# Q3.a)
TD1 <- data.frame(V1=TX4, V2=TX5); View(TD1)
# Q3.b)
TD2 <- data.frame(TD1, V3=TX6); View(TD2)
# Q4.a)
TX1[c(2,4)]
# Q4.b)
TM1[c(3,4),2]
# Q4.c)
nr=nrow(TD2); nc=ncol(TD2);TD2[c(nr-1,nr),c(nc-1,nc)]
######################################################################
# Chapter 3 Simple Computations and Manipulations
# 3.1 Computations of scalars
x1; a; x1-a
x1; b; x1*b
x1; x1^2
x1; x2; x1-x2
x1*x2
x1/x2
x5; 1/x5
sum(x1)
prod(x1)
log(x1)
exp(x1)
x1; m1; x1*m1
m2; x2; m2*x2
x1; x5; x1*x5
# 3.2 Computations of matrices
m1
nrow(m1)
ncol(m1)
t(m1)                   # transpose
diag(m1)                # diagonal elements
b <- c(1,2,3); diag(b)  # diag(1,2,3) in mathematics
diag(c(1,2,3))          # Equivalent use
diag(1,2,3)             # A 2 by 3 matrix with diagonal
# elements being 1
diag(3)                 # identity matrix of order 3
A <- m1%*%t(m1); A      # matrix multiplication
t(m1)%*%m1
X1 <- as.matrix(x1)     # A column vector of dimension 3
nrow(X1); ncol(X1)      # Dimensions of X1
X2 <- t(as.matrix(x2))  # A row vector of dimension 3
X2%*%X1                 # Inner product
X1%*%X2                 # Outer product
solve(A)                # inverse of singular matrix
A[3,3] <- 10; solve(A)  # inverse of non-singular matrix
solve(A, b)             # Solve A%*%X=b
solve(A, m1)            # Solve A%*%X=m1
det(A)                  # Determinant of A
A.eigen <- eigen(A)     # Eigenvalues and eigen vectors of A
A.eigen
# Check the eigenvalues and eigenvectors
A%*%A.eigen$vectors
A.eigen$values[1]*A.eigen$vectors[,1]
A.eigen$values[2]*A.eigen$vectors[,2]
A.eigen$values[3]*A.eigen$vectors[,3]
# 3.3 Computations of logical vectors
c1 <- x1!=2; x1; c1
c2 <- x2<=0; x2; c2
c3 <- x1=x2
c3 <- x1==x2; c3
c1 & c2
c1 | c2
c1 | c2 & c3        # AND superior to OR
c1 | (c2 & c3)      # Equivalent to the previous
(c1 | c2) & c3
# 3.4 Manipulations of vectors
v <- c(1:3); v          # Original vector
v[2:3] <- c(4,5); v     # Change values
v[5] <- 4; v            # Change length by adding values
v1 <- v[2:4]; v1        # The 2nd to the 4th values
v2 <- v[c(2,4)]; v2     # The 2nd and 4th values
v3 <- v[-c(2,4)]; v3    # Delete the 2nd and 4th values
v[v<4]                  # Values less than 4
# 3.5 Manipulations of matrix
m <- matrix(1:9, nrow=3, ncol=3); m
m[2:3,]           # Last 2 rows
m[,c(1,3)]        # The 1st and 3rd columns
m[,m[1,]<5]       # Columns with values in the 1st row <5
m[m[,1]>1,]       # Rows with values in the 1st column >1
con <- as.vector(m); con  # Concatenation
# 3.6 Manipulations of characters
# Character vectors
a <- c('Tutorial',"in",'R'); a
paste('Tutorial',"in",'R')  # Concatenate
cat('Tutorial',"in",'R')    # Concatenate and print
paste("Today is", date())
paste(c("X","Y"), 1:5, sep="o")
# Factors
state <- c("tas", "sa",  "qld", "nsw", "nsw", "nt",  "wa",  "wa",
"qld", "vic", "nsw", "vic", "qld", "qld", "sa",  "tas",
"sa",  "nt",  "wa",  "vic", "qld", "nsw", "nsw", "wa",
"sa",  "act", "nsw", "vic", "vic", "act")
statef <- factor(state); statef
levels(statef)
# A numerical variable can also be treated as/converted to a factor variable
factor(c(1,2,3,3,2,2,1))
# Equivalent usages
as.factor(c(1,2,3,3,2,2,1))
fac <- factor(c(1,2,3,3,2,2,1)); fac
# 3.7 Manipulations of data frames
data1
# List values of ONE variable
data1$x1            # Values of variable x1
data1[,1]           # Values of the 1st variable
# Cite variable(s)
data1[1]            # The 1st variable
data1[1:2]          # The 1st to the 2nd variables
data1[,1:2]         # The 1st to the 2nd variables
data1[c(1,3)]       # The 1st and the 3rd variables
# Cite observations
data1[1,]           # The 1st observation
data1[1:2,]         # The 1st to the 2nd observations
data1[c(1,3),]      # The 1st and the 3rd observations
# Select observations with restriction(s)
data1[data1$x1<1,]  # Observations with x1<1
data1[data1$x2>0,]  # Observations with x2>0
# Define a new data frame with more variables and observations
# for the following manipulations
v1 <- rep(1:3,3)
v2 <- rep(1:3, each=3)
v3 <- 1:9; v3[8] <- NA
data2 <- data.frame(v1, v2, v3)
View(data2)
# Remove omitted values
data3 <- na.omit(data2); View(data3)
# Remove the 3rd and 5th observations
data3 <- data3[c(-3,-5),]; View(data3)
# Reorder the data frame by values of v1
data3[order(data3$v1),]                   # Ascending order
data3[order(data3$v1, decreasing = T),]   # Descending order
data3[order(-data3$v1),]                  # Descending order
# Reordered by more than one variable
data3[order(data3$v2, -data3$v1),]
# Reorder the data frame from the last to the first observation
data2$Obs <- 1:nrow(data2)          # Add the natural order
data2[order(-data2$Obs),]           # Descending order
# Save selected R object(s)
SEL <- list(A, data1, A.eigen, pi.sim)
View(SEL)
names(SEL) <- c("Matrix", "Data_Frame",
"Estimation", "Function")
View(SEL)
save(SEL, file = "C:/Teaching/R Workshop/R_SEL.Rdata")
# Load the saved file
load("C:/Teaching/R Workshop/R_SEL.Rdata")
# Apply/Use saved R object
SEL$Matrix; SEL$Data_Frame$x1
pi.sim <- function(n) { # Define as a function
x <- runif(n,-1,1)  # n random x-coordinates
y <- runif(n,-1,1)  # n random y-coordinates
covered <- as.numeric(x^2+y^2<1)
# Indicator of (x,y) falling in the unit circle
pi.hat <- mean(covered)*4
pi.hat        # Output pi
}   # End of definition of function
# Save selected R object(s)
SEL <- list(A, data1, A.eigen, pi.sim)
View(SEL)
names(SEL) <- c("Matrix", "Data_Frame",
"Estimation", "Function")
View(SEL)
save(SEL, file = "C:/Teaching/R Workshop/R_SEL.Rdata")
# Load the saved file
load("C:/Teaching/R Workshop/R_SEL.Rdata")
# Apply/Use saved R object
SEL$Matrix; SEL$Data_Frame$x1
# Save selected R object(s)
SEL <- list(A, data1, A.eigen)
View(SEL)
names(SEL) <- c("Matrix", "Data_Frame",
"Estimation", "Function")
View(SEL)
save(SEL, file = "C:/Teaching/R Workshop/R_SEL.Rdata")
# Load the saved file
load("C:/Teaching/R Workshop/R_SEL.Rdata")
# Apply/Use saved R object
SEL$Matrix; SEL$Data_Frame$x1
names(SEL) <- c("Matrix", "Data_Frame",
"Estimation")
View(SEL)
SEL <- list(A, data1, A.eigen)
View(SEL)
names(SEL) <- c("Matrix", "Data_Frame",
"Estimation")
View(SEL)
save(SEL, file = "C:/Teaching/R Workshop/R_SEL.Rdata")
# Load the saved file
load("C:/Teaching/R Workshop/R_SEL.Rdata")
SEL$Matrix; SEL$Data_Frame$x1
